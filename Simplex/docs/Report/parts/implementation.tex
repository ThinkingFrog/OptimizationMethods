\documentclass[../body.tex]{subfiles}
\begin{document}
	\subsection{Алгоритм перевода из общей в каноническую форму}
	\textbf{Вход}: система уравнений
	\begin{enumerate}
		\item Проверяем знаки в системе
		\item Если <<$\le$>>, то к левой части добавляем $w[i]$, если <<$\ge$>>, то из левой части вычитаем $w[i]$, $w[i]\ge0$.
		\item Знаки неравенства в системе заменяем на равенство.
		\item Производим замену переменных: \\если $x[i]\le0$, то $x'[i]=-x[i]\ge0$; \\если $x[i]$ любого знака, то $x[i]=u[i]-v[i]$, $v[i],u[i] \ge 0$.
	\end{enumerate}
	\subsection{Алгоритм построения двойственной задачи}
Рассмотрим задачу минимума:
	\begin{equation}
		\begin{array}{ll}\label{eq:problem}
			(x[N],c[N])\longrightarrow \min_{x[N]}, x[N] \in S, x[N] \ge 0\\
			S :=\{x[N]|A[M,N]\cdot x[N] \gtreqless b[M]\}, x[N] \ge 0
		\end{array}
	\end{equation}
	Если же перед нами стоит задача максимума, то домножим вектор коэффициентов матрицы цели на $-1$.
	\begin{enumerate}
		\item Транспонируем заданную матрицу $ A^{T}$
		\item Новый вектор коэффицентов, стоящий в системе справа, равен вектору коэффициентов функции цели (\ref{eq:goal}).
		\item Новый вектор коэффициентов функции цели равен вектору коэффицентов, стоящему в системе (\ref{eq:limitation}) справа.
		\item Если ограничение на $x[i]\ge0$, то $i$-ая строка новой системы имеет знак <<$\le$>>.
		Если нет ограничения на знак, то $i$-ая строка новой системы имеет знак <<$=$>>.
		\item Если ограничение $i$-ой строки в исходной системе <<$\ge$>> (тк рассматриваем задачу  минимума), то ограничение на знак новой переменной $y[i]\ge0$.
		Если ограничение $i$-ой строки в исходной системе <<$=$>>, то $y[i]$ любого знака.
		\item Если исходная задача на поиск минимума, то двойственная на поиск максимума.
	\end{enumerate}
	\subsection{Алгоритм симплекс-метода}
	
	
	\textbf{Рассмотрим алгоритм в качестве псевдокода:}\\
	\SetKwRepeat{Do}{do}{while}
	\begin{algorithm}[H]
		\KwData{задача линейного программирования
			в стандартной форме}
		\KwResult{$n$-мерный вектор $\bar{x}=\left(\bar{x}_{j} \right) $, который является оптимальным решением задачи линейного программирования}
		\textbf{$Simplex(A,b,c):$}\\
		$(N,B,A,b,c,v) = Initialize-Simplex(A,b,c)$\\\
			Пусть $\Delta$ - новый вектор длиной $m$\\
		\While{$c_{j}$>0 для некоторого индекса $j \in N$}{
			Выбрать индекс $e\in B$, для которого $c_{e}>0$\\
			\For{каждого индекса $i \in B$}{
				\eIf{$a_{ie}>0$}{$\Delta_{i} = b_{i}/a_{ie}$}{$\Delta_{i} = \infty$}
			}
			Выбрать индекс $l \in B$, который минимизирует $\Delta_{l}$\
			
			\eIf{$\Delta_{l} == \infty$}{\textbf{return} задача неограничена}{$(N,B,A,b,c,v) = Pivot(N,B,A,b,c,v, l, e)$}
			\For{$i=1$ \textbf{to} $n$}{
				\eIf{$i\in B$}{
					$\bar{x}_{i}=b_{i}$
				}{
					$\bar{x}_{i}=0$
				}
			}
			\textbf{return} $(\bar{x}_{i}, \bar{x}_{2}, ... , \bar{x}_{n})$
		}
	
		\caption{Симплекс-метод решения задачи линейного программирования}
		
\end{algorithm}

\vspace{\baselineskip}

Процедура \textbf{Simplex} работает следующим образом:
\begin{itemize}
	\item В строке $2$ выполняется процедура $Initialize-Simplex(A,b,c)$, которая или определяет, что предложенная задача неразрешима, или возвращает каноническую форму, базисное решение которой является допустимым.
	\item Главная часть алгоритма содержится в цикле while в строках $4-16$. 
	
	Если все коэффициенты целевой функции отрицательны, цикл while завершается. В противном случае в строке $5$ мы выбираем в качестве вводимой переменной некоторую переменную $x_{e}$, коэффициент при которой в целевой функции положителен.
	\item  Затем, в строках $6-12$, выполняется проверка каждого ограничения и выбирается то,
	которое более всего лимитирует величину увеличения  $x_{e}$. 
	
	Базисная переменная, связанная с этим
	ограничением, выбирается в качестве выводимой переменной  $x_{i}$.
	\item 
	Если ни одно из ограничений не лимитирует возможность увеличения вводимой переменной, алгоритм выдает сообщение “задача неограниченная” (строка $15$). 
	
	В противном случае в строке $17$ роли вводимой и выводимой переменных
	меняются путем вызова описанной выше процедуры  $Pivot(N,B,A,b,c,v, l, e)$
	\item 
	В строках $19-25$ вычисляется решение $(\bar{x}_{i}, \bar{x}_{2}, ... , \bar{x}_{n})$ исходной задачи линейного
	программирования путем присваивания \\ \textbf{небазисным переменным} нулевого
	значения, \\\textbf{базисным переменным}  $\bar{x}_{i}$ — соответствующих значений $b_{i}$,\\ а строка $26$ возвращает эти значения.
	
\end{itemize}


	\subsection{Алгоритм перебора опорных векторов}
	Опорные векторы можно искать прямо по определению, перебирая все возможные базисы и находя соответствующие ненулевые коэффициенты из решения СЛАУ. 
	\vspace{\baselineskip}
	\SetKwRepeat{Do}{do}{while}
	
	\begin{algorithm}[H]\label{points}
		\KwData{$A[M,N], b[M], c[N]$ -- параметры задачи линейного программирования, поставленной в канонической форме ($m=|M|, n=|N|$)}
		\KwResult{опорный вектор $x_*[N]$, минимизирующий целевую функцию $(x[N],c[N])$}
		$V:=\emptyset$ -- будущий список опорных векторов\;
		\For{$i$ в диапазоне $\{0;C_m^n\}$}{
			$A[M,N_k] := $  extractMatrix($i$)\;
			\If{$|det(A[M,N_k])| > eps$}{
				$x[N_k]:=$ inv($A[M,N_k], b[M]$)\;
				Дополняем нулями до $x[N]$\;
				Добавляем $x[N]$ в $V$\;
			}
		}
		Выбираем $x_*$  -- любой вектор из $V$\;
		\For{$v \in V$}{
			\If{$(v,c) < (x_*,c)$}{
				$x_*:=v$\;
			}
		}
		
		\caption{Метод перебора опорных векторов решения задачи линейного программирования в канонической форме}
	\end{algorithm}
	\vspace{\baselineskip}
	
	Метод перебора крайних точек заключается в следующем:
	\begin{itemize}
\item	Рассматривается матрица $ A[M,N] $, где число строк матрицы меньше, чем число столбцов ($M<N$).
	\item Генерируются квадратные матрицы, выделяемые из матрицы  $ A[M,N] $, таких матриц получится $C_M^N$.
	\item Для каждой такой квадратной матрицы проверяется, что определитель отличен от нуля $|det(A[M,N_k])| > eps$
	Если это не так, то эта матрица к рассмотрению не принимается, иначе решается соответсвенно система $ A[M, N_k]x[N]=b[M] $ и находится решение.
	\item Если оказывается, что все компоненты решения удовлетворяют неравенству $\geq 0 $, то эта точка является полученной частью компонент крайней точки. Для тполучения крайней точки мы просто пополняем полученное решение нулевыми значениями соответсвующих компонент.
	\item Находим значение функции цели в крайней точке и запоминаем его.
	\item Генерируем следущую матрицу и продолжаем вышеперечисленные шаги.
	\item Сравниваем сохраненные значения между собой и выбираем то решение, которое соответсвует меньшему значению функции цели.
	
\end{itemize}

	
\end{document}